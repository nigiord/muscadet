% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{clusterMuscadet}
\alias{clusterMuscadet}
\title{Multi Omics Integration and Clustering on a \code{muscadet} Object}
\usage{
clusterMuscadet(
  x,
  method = c("seurat", "hclust"),
  omics = NULL,
  knn_imp = 10,
  quiet = FALSE,
  ...
)
}
\arguments{
\item{x}{A \code{muscadet} object containing omics data and previously computed
log R ratio matrices (\code{muscadet}).}

\item{method}{The clustering method to apply (\code{character} string). One of
\code{"seurat"} or \code{"hclust"}. For  medthod \code{"seurat"}, arguments for
\code{\link[=cluster_seurat]{cluster_seurat()}} should be provided, and for method \code{"hclust"}, arguments
for \code{\link[=cluster_hclust]{cluster_hclust()}} should be provided. Note: The \code{"seurat"} method can
only be applied for a maximum of 2 omics. Default is \code{"seurat"}.}

\item{omics}{Optional character vector specifying omic names to use for
clustering. Must match names of available omics in the \code{x} muscadet object.
If \code{NULL} (default), all available omics are used.}

\item{knn_imp}{Number of k nearest neighbors to use for imputing cluster
assignments of cells missing in one or more omics. Only relevant for more
than one omic.}

\item{quiet}{\code{TRUE} or \code{FALSE} (\code{logical}). Whether to turn off messages. By
default: \code{FALSE}.}

\item{...}{
  Arguments passed on to \code{\link[=cluster_seurat]{cluster_seurat}}, \code{\link[=cluster_hclust]{cluster_hclust}}
  \describe{
    \item{\code{res_range}}{A numeric non-negative vector specifying the resolution
values to use for \code{\link[Seurat:FindClusters]{Seurat::FindClusters()}} (\code{numeric} vector). Default is
\code{c(0.1, 0.2, 0.3, 0.4, 0.5)}.}
    \item{\code{dims_list}}{A list of vectors of PC dimensions to use for each omic
(\code{list}). Must match the length of \code{mat_list} (e.g., list(1:8) for 1 omic ;
list(1:8, 1:8) for 2 omics). Default is the first 8 dimensions for each
provided omic.}
    \item{\code{algorithm}}{Integer specifying the algorithm for modularity optimization
by \link[Seurat:FindClusters]{Seurat::FindClusters} (\code{1} = original Louvain algorithm; \code{2} = Louvain algorithm with multilevel
refinement; \code{3} = SLM algorithm; \code{4} = Leiden algorithm). Leiden requires the
leidenalg python. Default is \code{1}.}
    \item{\code{knn_seurat}}{Integer specifying the number of nearest neighbors used for
graph construction with Seurat functions \code{\link[Seurat:FindNeighbors]{Seurat::FindNeighbors()}}
(\code{k.param}) or \code{\link[Seurat:FindMultiModalNeighbors]{Seurat::FindMultiModalNeighbors()}} (\code{k.nn}) (\code{integer}).
Default is \code{20}.}
    \item{\code{knn_range_seurat}}{Integer specifying the approximate number of nearest
neighbors to compute for \code{\link[Seurat:FindMultiModalNeighbors]{Seurat::FindMultiModalNeighbors()}} (\code{knn.range})
(\code{integer}). Default is \code{200}.}
    \item{\code{k_range}}{A numeric vector of integers (â‰¥2) specifying the cluster
numbers (k) to extract from hierarchical clustering (\code{numeric} vector).
Default is from 2 to 10.}
    \item{\code{dist_method}}{A string specifying the distance method for
\code{\link[Rfast:Dist]{Rfast::Dist()}} (e.g., \code{"euclidean"}, \code{"manhattan"}, \code{"cosine"})
(\code{character} string). Default is \code{"euclidean"}.}
    \item{\code{hclust_method}}{A string specifying the hierarchical clustering linkage
method for \code{\link[fastcluster:hclust]{fastcluster::hclust()}} (e.g., \code{"ward.D"}, \code{"average"})
(\code{character} string). Default is \code{"ward.D"}.}
    \item{\code{weights}}{A numeric vector of non-negative values of length equal to the
number of omic (internally normalized to sum to 1) (\code{numeric} vector). It
specifies the relatives weights of each omic for SNF with
\code{\link[=weightedSNF]{weightedSNF()}}. Omics with a weight of 0 will not contribute to
the clustering. If \code{NULL} (default), weights are uniform.}
  }}
}
\value{
The input \code{\link{muscadet}} object with its \code{clustering} slot updated. This slot contains:
\describe{
\item{params}{List of parameters used for clustering (\code{list}).}
\item{...}{Output objects depending on the method.}
\item{clusters}{A list of cluster assignments (imputed if needed) for each value in \code{k_range} or \code{res_range}.}
\item{partition.opt}{Name of the optimal partition based on maximum average silhouette width.}
\item{silhouette}{A list of silhouette objects and summary statistics.}
}
\itemize{
\item \code{params}: List of parameters used for clustering (\code{list}).
\item \code{...}: Output objects depending on the method (e.g. graph object for
\code{"seurat"}; hclust object for \code{"hclust"})
\item \code{clusters}: A named list of cluster partitions (named vectors of cluster
labels) for all cells (imputed clusters assignments for non-common cells),
for each value in \code{k_range} or \code{res_range} (\code{list}).
\item \code{silhouette}: A list of silhouette objects and widths for each cluster partition.
\item \code{partition.opt}: Name of the optimal cluster partition based on maximum average
silhouette width.
}
}
\description{
Performs integration of multi omics and clustering of cells based on log
ratio data contained in a \code{\link{muscadet}} object.
}
\details{
Two methods are available for integration and clustering of common cells
between omics:
\itemize{
\item Method \code{seurat} uses nearest neighbors for integration followed by
graph-based clustering.
\item Method \code{hclust} uses Similarity Network Fusion (SNF) for integration
followed by hierarchical clustering.
}

Then, clusters are imputed for cells missing data in at least one omic, by
similarity using nearest neighbor cells.

Finally, silhouette widths are computed on the integrated distance matrix to
help identify the optimal clustering partition.
}
\examples{
# Load example muscadet object
data(muscadet_obj)

# Perform clustering with "seurat" method
muscadet_obj <- clusterMuscadet(
  x = muscadet_obj,
  method = "seurat",
  res_range = c(0.5, 0.8),
  dims_list = list(1:8, 1:8),
  knn_seurat = 10, # to adapt for low number of cells in example data
  knn_range_seurat = 30 # to adapt for low number of cells in example data
)

# Perform clustering with "hclust" method
muscadet_obj <- clusterMuscadet(
  x = muscadet_obj,
  k_range = 2:4,
  method = "hclust",
  dist_method = "euclidean",
  hclust_method = "ward.D",
  weights = c(1, 1)
)

# Retrieve cluster assignments
clusters <- muscadet_obj$clustering$clusters
lapply(clusters, table)

}
\seealso{
Methodology and functionality:
\itemize{
\item \linkS4class{muscadet}
\item \code{\link[=cluster_seurat]{cluster_seurat()}} for graph-based clustering using Seurat.
\item \code{\link[=cluster_hclust]{cluster_hclust()}} for hierarchical clustering of SNF-fused distances.
\item \code{\link[=weightedSNF]{weightedSNF()}} for weighted Similarity Network Fusion (SNF).
\item \code{\link[=imputeClusters]{imputeClusters()}} for imputing cluster labels across omics.
}

Visualization:
\itemize{
\item \code{\link[=heatmapMuscadet]{heatmapMuscadet()}} to plot clustering result as heatmap.
\item \code{\link[=plotSil]{plotSil()}} to plot silhouette widths.
\item \code{\link[=plotIndexes]{plotIndexes()}} to plot several normalized cluster validation indexes.
}

Select clusters to continue with CNA calling:
\itemize{
\item \code{\link[=assignClusters]{assignClusters()}} to assign final cluster assignments in the \code{muscadet}
object after cluster partition validation.
}
}
